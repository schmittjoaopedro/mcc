package memory.compiler.engine;

import memory.compiler.message.MemoryCompilerException;
import memory.compiler.message.MessageCompiler;
import memory.compiler.message.MessageStatus;
import memory.compiler.object.SourceClass;
import memory.compiler.object.SourceTask;
import memory.compiler.pmd.MemoryPMDValidator;

import javax.tools.*;
import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * This class manage the objects used by the compiler.
 * The native compiler of JVM is used to generate
 * the byte codes. The most part of the methods receive
 * SourceClasses to compile, and in these same references
 * the generated bytecode is assigned.
 *
 * @author schmittjoaopedro
 * @version 1.0.0
 * @since 1.0.0
 *
 */
public class MemoryClassCompiler {

    private static final String ERROR_IN_COMPILATION_OF_CLASS = "Error in compilation of class";

    private static final String YOU_DO_NOT_PASS_ANYTHING_TO_BE_COMPILED = "You do not pass anything to be compiled";

    /**
     * Code quality analysis
     */
    private MemoryPMDValidator pmd;

    /**
     * JVM compiler
     */
    private JavaCompiler compiler;

    /**
     * Standard file manager used by JVM used with file system
     */
    StandardJavaFileManager standardJavaFileManager;

    /**
     * Classpath configuration
     */
    private List<String> classpath;

    /**
     * Initiate javaCompiler
     */
    public MemoryClassCompiler() {
        this.pmd = new MemoryPMDValidator();
        this.compiler = ToolProvider.getSystemJavaCompiler();
        this.standardJavaFileManager = compiler.getStandardFileManager(null, null, null);
    }

    /**
     * Initiate javaCompiler with class path
     */
    public MemoryClassCompiler(List<String> classpath) {
        this.pmd = new MemoryPMDValidator();
        this.compiler = ToolProvider.getSystemJavaCompiler();
        this.standardJavaFileManager = compiler.getStandardFileManager(null, null, null);
        this.setClassPath(String.join(File.pathSeparator, classpath));
    }

    /**
     * Try compile a singleSource class.
     *
     * @param sourceClass
     * @return sourceClass
     */
    public SourceClass compile(SourceClass sourceClass) {
        SourceTask temporarySourceTask = new SourceTask();
        if(temporarySourceTask.addSourceClass(sourceClass)) {
            this.compile(temporarySourceTask);
        }
        return sourceClass;
    }

    /**
     *
     * Use a source task to compile the classes. Use the file manager,
     * memory file manager and java file object to create the byte code
     * for each SourceClass.
     *
     * @param sourceTask
     *
     * @return sourceTask
     * @throws MemoryCompilerException
     */
    public SourceTask compile(SourceTask sourceTask) {
        if(!sourceTask.getSourcesClass().isEmpty()) {
            MemoryCompilerManager memoryJavaFileManager = new MemoryCompilerManager(this.standardJavaFileManager, sourceTask);
            List<JavaFileObject> filesToCompile = new ArrayList<JavaFileObject>();
            DiagnosticCollector<JavaFileObject> diagnostics = new DiagnosticCollector<JavaFileObject>();
            for(SourceClass sourceClass : sourceTask.getSourcesClass()) {
                filesToCompile.add(new InputMemoryJavaFileObject(sourceClass));
            }

            JavaCompiler.CompilationTask compilationTask = this.compiler.getTask(null, memoryJavaFileManager, diagnostics, this.classpath, null, filesToCompile);
            compilationTask.call();

            if(!diagnostics.getDiagnostics().isEmpty()) {
                throw new MemoryCompilerException(new MessageCompiler(ERROR_IN_COMPILATION_OF_CLASS, MessageStatus.FAILED, diagnostics.getDiagnostics()));
            }

            return sourceTask;
        } else {
            throw new MemoryCompilerException(YOU_DO_NOT_PASS_ANYTHING_TO_BE_COMPILED, MessageStatus.FAILED);
        }
    }

    /**
     * Check PMD before compile
     *
     * @param sourceClass
     * @return sourceClasll
     * @throws MemoryCompilerException
     */
    public SourceClass checkAndCompile(SourceClass sourceClass) {
        this.pmd.check(sourceClass);
        return this.compile(sourceClass);
    }

    /**
     * Check PMD for a list of classes before run compiler, if some class broke,
     * all process are stopped and a exception is thrown.
     *
     * @param sourceTask
     * @return sourceTasl
     * @throws MemoryClassCompiler
     */
    public SourceTask checkAndCompile(SourceTask sourceTask) {
        this.pmd.check(sourceTask);
        return this.compile(sourceTask);
    }

    /**
     * Set the class path and other arguments
     *
     * @param classpath
     */
    public void setClassPath(String classpath) {
        this.classpath = Arrays.asList("-classpath", classpath);
    }
}
